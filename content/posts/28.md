---
title: "多线程与并发原理"
date: 2020-06-22T12:53:10+08:00
draft: true
---

# 多线程与并发原理

为什么需要多线程
---
* CPU：你们都慢！死！了！（CPU实在是太快了，以至于想要尽可能的利用CPU的速度，不能光等待，可以做点其他事）
* 现代CPU都是多核的,多线程可以尽可能的实现出多核的价值
  * 理论上具有天然并发的能力(1GHZ: 1G * cycle(时间周期)/秒 = 1*cycle/ns(纳秒))
  * 堆核心：又要快又可以避免发热量太大(Q=i²Rt)
* Java的执⾏模型是同步/阻塞(block)的
* 默认情况下只有⼀个线程
  * 处理问题⾮常⾃然
  * 但是具有严重的性能问题

我能不能多请⼏个⼈来⼲活？
---
* 开启⼀个新的线程
  * Thread
     * Java中只有这么⼀种东⻄代表线程
     * start⽅法才能并发执⾏！
     * 每多开⼀个线程，就多⼀个执⾏流
     *  ⽅法栈(局部变量)是线程私有的
     * 静态变量/类变量是被所有线程共享的(伴随着的问题是几乎所有的坑都来自这里)

线程难的本质原因是
你要看着同⼀份代码，
想象不同的⼈在疯狂地以乱序执⾏它
---
* 难就难在共享变量的处理

演示多线程带来的性能提升
---
* 对于IO密集型应⽤极其有⽤
  * ⽹络IO（通常包括数据库）：处理完请求，发送给用户要经过网络IO，它很慢，等它的时间不如去做点其他事情（处理其他用户的请求）
  * ⽂件IO
* 对于CPU密集型应⽤稍有折扣：不适合使用多线程，一个就基本够CPU受的了
* 性能提升的上限在哪⾥？
  * 单核CPU 100%
  * 多核CPU N*100%

昂贵的线程
---
* 能不能使⽤线程达到⽆穷⽆尽的性能提升?
  * ⼗个⼥⼈⼀个⽉能⽣⼀个孩⼦么？
* 线程的昂贵性在于
  * 第⼀，CPU切换上下⽂很慢
  * 第⼆，线程需要占⽤内存等系统资源
* 如果你的应⽤⼀天才⼏个⽤户
  * new Thread().start()
* 如果你的应⽤负载很⾼
  * 使⽤线程池:JUC包

线程安全(在多线程的环境下，每当看到一个东西时，都要先判断它是不是线程安全的(进去，搜索thread))
---
* 你享⽤了多线程的便利，就要付出代价
  * 原⼦性：指一个不能中断的操作，要么完成，要么不开始
  * 共享变量
  * 默认的实现⼏乎都不是线程安全的

线程不安全的表现
---
* 并发带来的数据错误
  * i++
  * if-then-do ：通过访问共享变量而造成的不安全性
* 死锁
* 著名的HashMap的死循环问题
* 写⼀段代码来重现死锁
* 预防死锁产⽣的原则：
  * 所有的线程都按照相同的顺序获得资源的锁
* 死锁问题的排查
* 多线程的经典问题：哲学家⽤餐

线程安全
---
* 实现线程安全的基本⼿段
  * 不可变类
     * Integer/String/....

线程安全
---
* 实现线程安全的基本⼿段
  * JUC包
     * AtomicInteger/...
     * ConcurrentHashMap
         * 任何使⽤HashMap有线程安全问题的地⽅
         * 都⽆脑地使⽤ConcurrentHashMap替换即可。
     * ReentrantLock
     * ...
  * synchronized同步块
  * 同步块同步了什么东⻄？
     * synchronized(⼀个对象) 把这个对象当成锁
     * Static synchronized⽅法 把Class对象当成锁
     * 实例的synchronnized⽅法把该实例当成锁
* Collections.synchronized

Object类⾥的线程⽅法
---
* 线程的历史
  * Java从⼀开始就把线程作为语⾔特性，提供语⾔级的⽀持
* 为什么Java中的所有对象都可以成为锁？
  * Object.wait()/notify()/notifyAll()⽅法
  * 线程的状态与线程调度
  * 【扩展】为什么说Java的线程

多线程的经典问题
⽣产者/消费者模型
---
* 使⽤三种⽅法来解决它
  * wait/notify/notifyAll
  * Lock/Condition
  * BlockingQueue：需要2个 一个用来关联，一个用来控制协调这个关联

线程池与Callable/Future
---
* 什么是线程池
  * 线程是昂贵的（Java线程模型的缺陷）
    * java的缺陷：java的线程是跟操作系统绑定的，所以线程的数量有上限
  * 线程池是预先定义好的若⼲个线程
    * 避免每次 创建/销毁线程所产生的开销
  * Java中的线程池
* Callable/Future
  * 类⽐Runnable，Callable可以返回值，抛出异常
  * Future代表⼀个“未来才会返回的结果”
* 实战：多线程的WordCount
  * 给定的N个文件和N个线程，创造一个线程池，里面的每个线程从分别读取文件的每一行，统计其中每个单词出现的次数 
  * 思路：
  * 首先确定返回值需要满足需求：Map<String, Integer>
  * 因为是多线程中使用的Map,所以这里需要使用ConcurrentHashMap,所以创建一个名为filesResult的成员变量
  * 先提取一个文件, 根据这个文件.path创建一个名为reader的BufferedReader
  * 在这个基础上创建N个线程，for()
  * 给每个线程一份说明书来执行的任务，并且现在是多个循环，也是为了方便阅读，这里就创建一个外部类，
  * 这个外部类需要实现这些功能，最好的办法是实现一个接口，覆盖里面的方法，实现自己想要的功能，
  * 我想要的结果是：这个类可以将reader中的一行的统计结果添加到其中，所以我需要在外部类创建一个构造器，传递参数进去，
  * 我选择的接口是Runnable或者Callable,覆盖里面的方法，一个有返回值一个没有，反正都是用的共享变量
  * 最后直接返回这个共享变量就行了
